<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadowing é€å¥ç·´ç¿’å·¥å…·</title>
    <style>
        :root {
            --primary: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg-done: #d1fae5;
            --bg-current: #fef3c7;
            --bg-record: #fee2e2;
            --bg-listen: #e0f2fe;
        }

        body { font-family: system-ui, -apple-system, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; line-height: 1.6; color: #333; }
        h1, h2 { color: #1e293b; }
        
        /* å€åŸŸæ§åˆ¶ */
        .section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .hidden { display: none !important; }

        /* è¼¸å…¥æ§åˆ¶ */
        .input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
        input[type="text"], input[type="password"] { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        
        /* æŒ‰éˆ• */
        .btn { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: 0.2s; background: #e2e8f0; color: #333; }
        .btn-primary { background: var(--primary); color: white; }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { background: #cbd5e1; cursor: not-allowed; }

        /* ç·´ç¿’å€ä½ˆå±€ */
        .practice-container { display: grid; gap: 20px; }
        
        /* ç‹€æ…‹æ¡† */
        .status-box { padding: 15px; border-radius: 8px; text-align: center; font-size: 1.2em; font-weight: bold; margin-bottom: 20px; transition: all 0.3s; border: 2px solid transparent; }
        .status-box.listening { background: var(--bg-listen); border-color: #0ea5e9; }
        .status-box.recording { background: var(--bg-record); border-color: var(--danger); }
        .status-box.completed { background: var(--bg-done); border-color: var(--success); }

        /* å¥å­åˆ—è¡¨ */
        .sentence-list { max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; }
        .sentence-item { padding: 10px 15px; border-bottom: 1px solid #f1f5f9; cursor: pointer; transition: 0.2s; }
        
        /* å¥å­ç‹€æ…‹æ¨£å¼ */
        .sentence-item.done { background: var(--bg-done); border-left: 4px solid var(--success); opacity: 0.8; }
        .sentence-item.current { background: var(--bg-current); border-left: 4px solid var(--warning); font-size: 1.3em; font-weight: bold; padding: 20px; }
        
        /* æ³¢å½¢åœ– */
        .waveform-container { margin-top: 20px; }
        canvas { width: 100%; height: 100px; background: #f8fafc; border-radius: 4px; border: 1px solid #e2e8f0; margin-bottom: 10px; }
        .waveform-label { font-size: 0.9em; color: #64748b; margin-bottom: 4px; }

        /* æ§åˆ¶æŒ‰éˆ•å€ */
        .controls { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
    </style>
</head>
<body>

<div class="section">
    <h1>Shadowing é€å¥ç·´ç¿’å·¥å…·</h1>
    <p>å°ˆæ³¨ç·´ç¿’ï¼Œé€å¥é€²æ­¥</p>
</div>

<div id="setupSection" class="section">
    <h2>ğŸ› ï¸ è¨­å®šèˆ‡ä¸Šå‚³</h2>
    
    <div class="input-group">
        <label>1. ä¸Šå‚³éŸ³è¨Šæª”æ¡ˆ (MP3, M4A, WAV)</label>
        <input type="file" id="audioInput" accept="audio/*">
    </div>

    <div class="input-group">
        <label>2. é€å­—ç¨¿ä¾†æº</label>
        <div style="margin-bottom: 10px;">
            <button class="btn btn-primary" onclick="setMode('manual')">âœï¸ æ‰‹å‹•è¼¸å…¥/è²¼ä¸Š</button>
            <button class="btn" onclick="setMode('auto')">ğŸ¤– AI è‡ªå‹•ç”¢ç”Ÿ (Whisper)</button>
        </div>
        
        <div id="manualInputArea">
            <textarea id="transcriptText" placeholder="åœ¨æ­¤è²¼ä¸Šé€å­—ç¨¿...&#10;æ”¯æ´æ ¼å¼ï¼š&#10;1. ç´”æ–‡å­—ï¼ˆæ¯å¥ä¸€è¡Œï¼‰&#10;2. æ™‚é–“æˆ³è¨˜ï¼ˆ0:00-0:05 å¥å­å…§å®¹ï¼‰"></textarea>
        </div>

        <div id="autoInputArea" class="hidden">
            <label>OpenAI API Key (ä¸æœƒå„²å­˜æ–¼ä¼ºæœå™¨)</label>
            <input type="password" id="apiKey" placeholder="sk-...">
            <p style="font-size: 0.9em; color: #666;">è²»ç”¨ç´„ $0.006/åˆ†é˜ï¼Œè«‹ç¢ºä¿å¸³æˆ¶æœ‰é¡åº¦ã€‚</p>
        </div>
    </div>

    <button id="startBtn" class="btn btn-primary" style="width: 100%;" disabled>ğŸš€ é–‹å§‹ç·´ç¿’</button>
</div>

<div id="practiceSection" class="section hidden">
    <div class="practice-container">
        <div>
            <h3 id="progressDisplay">æº–å‚™ä¸­...</h3>
            
            <div id="statusBox" class="status-box">
                ç­‰å¾…é–‹å§‹...
            </div>

            <div id="waveformArea" class="waveform-container hidden">
                <div class="waveform-label">ğŸ“Š åŸéŸ³æ³¢å½¢</div>
                <canvas id="originalWaveform"></canvas>
                
                <div class="waveform-label">ğŸ¤ ä½ çš„éŒ„éŸ³</div>
                <canvas id="recordingWaveform"></canvas>
                
                <div class="controls">
                    <button class="btn" onclick="retrySentence()">ğŸ”„ å†ç·´ä¸€æ¬¡</button>
                    <button class="btn btn-primary" onclick="nextSentence()">âœ… ä¸‹ä¸€å¥</button>
                </div>
            </div>
        </div>

        <div class="sentence-list" id="sentenceList">
            </div>
    </div>
</div>

<audio id="audioPlayer" style="display:none;"></audio>

<script>
/**
 * å…¨åŸŸç‹€æ…‹ç®¡ç†
 */
const state = {
    sentences: [],
    currentIndex: 0,
    audioBlob: null,
    audioBuffer: null, // ç”¨æ–¼ç¹ªè£½æ³¢å½¢
    audioContext: new (window.AudioContext || window.webkitAudioContext)(),
    mode: 'manual', // manual | auto
    isPlaying: false
};

const dom = {
    audioInput: document.getElementById('audioInput'),
    transcriptText: document.getElementById('transcriptText'),
    startBtn: document.getElementById('startBtn'),
    setupSection: document.getElementById('setupSection'),
    practiceSection: document.getElementById('practiceSection'),
    sentenceList: document.getElementById('sentenceList'),
    statusBox: document.getElementById('statusBox'),
    audioPlayer: document.getElementById('audioPlayer'),
    waveformArea: document.getElementById('waveformArea'),
    progressDisplay: document.getElementById('progressDisplay'),
    apiKey: document.getElementById('apiKey')
};

// åˆå§‹åŒ–
dom.audioInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (file) {
        state.audioBlob = file;
        dom.audioPlayer.src = URL.createObjectURL(file);
        
        // è§£æ AudioBuffer ç”¨æ–¼ç•«åœ–
        const arrayBuffer = await file.arrayBuffer();
        state.audioBuffer = await state.audioContext.decodeAudioData(arrayBuffer);
        
        checkStartReady();
    }
});

dom.transcriptText.addEventListener('input', checkStartReady);
dom.apiKey.addEventListener('input', checkStartReady);
dom.startBtn.addEventListener('click', startPractice);

function setMode(mode) {
    state.mode = mode;
    if (mode === 'manual') {
        document.getElementById('manualInputArea').classList.remove('hidden');
        document.getElementById('autoInputArea').classList.add('hidden');
    } else {
        document.getElementById('manualInputArea').classList.add('hidden');
        document.getElementById('autoInputArea').classList.remove('hidden');
    }
    checkStartReady();
}

function checkStartReady() {
    let ready = false;
    if (state.audioBlob) {
        if (state.mode === 'manual' && dom.transcriptText.value.trim().length > 0) ready = true;
        if (state.mode === 'auto' && dom.apiKey.value.trim().length > 0) ready = true;
    }
    dom.startBtn.disabled = !ready;
}

/**
 * æ ¸å¿ƒæµç¨‹ï¼šé–‹å§‹ç·´ç¿’
 */
async function startPractice() {
    dom.startBtn.textContent = 'è™•ç†ä¸­...';
    dom.startBtn.disabled = true;

    try {
        if (state.mode === 'auto') {
            await generateTranscriptWithWhisper();
        } else {
            parseManualTranscript();
        }

        if (state.sentences.length === 0) {
            alert('ç„¡æ³•è§£æå‡ºå¥å­ï¼Œè«‹æª¢æŸ¥è¼¸å…¥æ ¼å¼ã€‚');
            return;
        }

        // åˆ‡æ›ä»‹é¢
        dom.setupSection.classList.add('hidden');
        dom.practiceSection.classList.remove('hidden');
        
        renderSentenceList();
        runSentenceRoutine(); // é–‹å§‹ç¬¬ä¸€å¥æµç¨‹

    } catch (err) {
        alert('ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
        dom.startBtn.disabled = false;
        dom.startBtn.textContent = 'ğŸš€ é–‹å§‹ç·´ç¿’';
    }
}

/**
 * è§£ææ‰‹å‹•è¼¸å…¥çš„é€å­—ç¨¿
 */
function parseManualTranscript() {
    const text = dom.transcriptText.value.trim();
    const lines = text.split('\n');
    state.sentences = [];

    lines.forEach(line => {
        line = line.trim();
        if (!line) return;

        // å˜—è©¦åŒ¹é…æ™‚é–“æˆ³è¨˜ M:SS-M:SS (æ”¯æ´ä¸€ä½æ•¸æˆ–å…©ä½æ•¸åˆ†)
        const timestampMatch = line.match(/^(\d+):(\d{2})-(\d+):(\d{2})\s+(.+)$/);
        
        if (timestampMatch) {
            const start = parseInt(timestampMatch[1]) * 60 + parseInt(timestampMatch[2]);
            const end = parseInt(timestampMatch[3]) * 60 + parseInt(timestampMatch[4]);
            state.sentences.push({ text: timestampMatch[5], start, end });
        } else {
            // ç´”æ–‡å­—æ¨¡å¼
            state.sentences.push({ text: line, start: null, end: null });
        }
    });
}

/**
 * ä½¿ç”¨ OpenAI Whisper API ç”Ÿæˆé€å­—ç¨¿
 */
async function generateTranscriptWithWhisper() {
    const formData = new FormData();
    formData.append('file', state.audioBlob);
    formData.append('model', 'whisper-1');
    formData.append('response_format', 'verbose_json');
    formData.append('timestamp_granularities[]', 'word');

    const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${dom.apiKey.value.trim()}` },
        body: formData
    });

    if (!response.ok) throw new Error('OpenAI API Error: ' + response.statusText);

    const data = await response.json();
    processWhisperData(data.words);
}

/**
 * Whisper åˆ†å¥é‚è¼¯ (è¦å‰‡ï¼šæ¨™é»æˆ–é•·åº¦)
 */
function processWhisperData(words) {
    state.sentences = [];
    let currentSentence = [];
    let wordCount = 0;

    words.forEach(wordObj => {
        currentSentence.push(wordObj);
        wordCount++;
        
        const text = wordObj.word;
        const isPunctuation = /[ã€‚ï¼ï¼Ÿ.!?]/.test(text);
        
        if (isPunctuation || wordCount >= 15) {
            // å»ºç«‹å¥å­
            const start = currentSentence[0].start;
            const end = currentSentence[currentSentence.length - 1].end;
            const sentenceText = currentSentence.map(w => w.word).join('');
            
            state.sentences.push({ text: sentenceText, start, end });
            
            // é‡ç½®
            currentSentence = [];
            wordCount = 0;
        }
    });

    // è™•ç†å‰©é¤˜çš„å–®è©
    if (currentSentence.length > 0) {
        const start = currentSentence[0].start;
        const end = currentSentence[currentSentence.length - 1].end;
        const sentenceText = currentSentence.map(w => w.word).join('');
        state.sentences.push({ text: sentenceText, start, end });
    }
}

/**
 * ç·´ç¿’æµç¨‹æ§åˆ¶
 */
async function runSentenceRoutine() {
    const sentence = state.sentences[state.currentIndex];
    
    // UI æ›´æ–°
    updateUIForSentence();
    dom.waveformArea.classList.add('hidden');
    
    // 1. ç¬¬ä¸€æ¬¡æ’­æ”¾
    setStatus('listening', 'ğŸµ ç¬¬ 1 æ¬¡æ’­æ”¾ (ä»”ç´°è†è½)');
    await playSegment(sentence);
    await wait(500);

    // 2. ç¬¬äºŒæ¬¡æ’­æ”¾
    setStatus('listening', 'ğŸµ ç¬¬ 2 æ¬¡æ’­æ”¾ (æº–å‚™æ¨¡ä»¿)');
    await playSegment(sentence);
    await wait(500);

    // 3. éŒ„éŸ³
    setStatus('recording', 'ğŸ¤ è«‹è·Ÿè®€ (éŒ„éŸ³ä¸­...)');
    const duration = (sentence.start !== null && sentence.end !== null) 
        ? (sentence.end - sentence.start) * 1000 
        : 5000; // é è¨­ 5 ç§’
    
    const recordedBlob = await recordAudio(duration);
    
    // 4. é¡¯ç¤ºçµæœ
    setStatus('completed', 'ğŸ“Š æ¯”å°ä½ çš„ç™¼éŸ³');
    dom.waveformArea.classList.remove('hidden');
    
    // ç¹ªè£½æ³¢å½¢
    drawWaveform(state.audioBuffer, 'originalWaveform', '#2563eb', sentence.start, sentence.end);
    
    const recordedArrayBuffer = await recordedBlob.arrayBuffer();
    const recordedAudioBuffer = await state.audioContext.decodeAudioData(recordedArrayBuffer);
    drawWaveform(recordedAudioBuffer, 'recordingWaveform', '#ef4444', 0, recordedAudioBuffer.duration);
}

// æ’­æ”¾æ§åˆ¶
function playSegment(sentence) {
    return new Promise(resolve => {
        const audio = dom.audioPlayer;
        
        if (sentence.start !== null) {
            audio.currentTime = sentence.start;
            audio.play();
            
            const checker = setInterval(() => {
                if (audio.currentTime >= sentence.end) {
                    audio.pause();
                    clearInterval(checker);
                    resolve();
                }
            }, 50);
        } else {
            audio.currentTime = 0;
            audio.play();
            audio.onended = resolve;
        }
    });
}

// éŒ„éŸ³æ§åˆ¶
async function recordAudio(durationMs) {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mediaRecorder = new MediaRecorder(stream);
    const chunks = [];

    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.start();

    return new Promise(resolve => {
        setTimeout(() => {
            mediaRecorder.stop();
        }, durationMs);

        mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            stream.getTracks().forEach(track => track.stop()); // é—œé–‰éº¥å…‹é¢¨
            resolve(blob);
        };
    });
}

// æ³¢å½¢ç¹ªè£½
function drawWaveform(fullAudioBuffer, canvasId, color, startTime = 0, endTime = null) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // è™•ç† Retina è§£æåº¦
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const width = rect.width;
    const height = rect.height;
    
    // è¨ˆç®—è¦ç¹ªè£½çš„è³‡æ–™ç¯„åœ
    const sampleRate = fullAudioBuffer.sampleRate;
    const startSample = Math.floor(startTime * sampleRate);
    const endSample = endTime ? Math.floor(endTime * sampleRate) : fullAudioBuffer.length;
    
    const rawData = fullAudioBuffer.getChannelData(0); // å–å·¦è²é“
    const dataSlice = rawData.slice(startSample, endSample);
    
    const step = Math.ceil(dataSlice.length / width);
    const amp = height / 2;

    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = color;
    
    ctx.beginPath();
    for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;
        
        for (let j = 0; j < step; j++) {
            const datum = dataSlice[(i * step) + j];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
        }
        
        ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
    }
}

// è¼”åŠ©åŠŸèƒ½
const wait = ms => new Promise(r => setTimeout(r, ms));

function setStatus(type, text) {
    dom.statusBox.className = `status-box ${type}`;
    dom.statusBox.textContent = text;
}

function updateUIForSentence() {
    dom.progressDisplay.textContent = `ç¬¬ ${state.currentIndex + 1} / ${state.sentences.length} å¥`;
    renderSentenceList();
    
    // æ»¾å‹•åˆ°ç•¶å‰å¥å­
    const currentEl = document.querySelector('.sentence-item.current');
    if (currentEl) currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function renderSentenceList() {
    dom.sentenceList.innerHTML = state.sentences.map((s, idx) => {
        let className = 'sentence-item';
        let icon = '';
        
        if (idx < state.currentIndex) {
            className += ' done';
            icon = 'âœ“ ';
        } else if (idx === state.currentIndex) {
            className += ' current';
            icon = 'â†’ ';
        }

        const timeInfo = (s.start !== null) 
            ? `<span style="font-size:0.8em; color:#666; margin-left:10px;">[${formatTime(s.start)}-${formatTime(s.end)}]</span>` 
            : '';

        return `<div class="${className}">${icon}${s.text}${timeInfo}</div>`;
    }).join('');
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
}

// æŒ‰éˆ•å‹•ä½œ
window.retrySentence = () => {
    runSentenceRoutine();
};

window.nextSentence = () => {
    if (state.currentIndex < state.sentences.length - 1) {
        state.currentIndex++;
        runSentenceRoutine();
    } else {
        setStatus('completed', 'ğŸ‰ æ­å–œå®Œæˆæ‰€æœ‰ç·´ç¿’ï¼');
        dom.waveformArea.classList.add('hidden');
        alert('æ­å–œå®Œæˆï¼');
    }
};
</script>

</body>
</html>
