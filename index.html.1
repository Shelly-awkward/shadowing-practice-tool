<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadowing Pro å®‰å…¨ç‰ˆ</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #121212; color: #e0e0e0; padding: 16px; display: flex; flex-direction: column; height: 100vh; box-sizing: border-box; }
        h1 { font-size: 1.4rem; text-align: center; color: #60a5fa; margin-bottom: 20px; }
        .card { background: #252525; padding: 20px; border-radius: 16px; margin-bottom: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .btn { background: #2563eb; color: white; border: none; padding: 18px; border-radius: 12px; font-size: 1.2rem; width: 100%; font-weight: bold; margin-top: 10px; }
        .btn:disabled { background: #404040; color: #888; }
        .btn-control { background: #dc2626; }
        .btn-control.paused { background: #059669; }
        .hidden { display: none !important; }
        input[type="file"], input[type="password"] { font-size: 1rem; padding: 10px; width: 100%; box-sizing: border-box; margin-bottom: 10px; border-radius: 8px; border: 1px solid #444; background: #333; color: white; }
        
        /* ç‹€æ…‹é¡¯ç¤º */
        #statusBox { font-size: 1.3rem; text-align: center; padding: 20px; border-radius: 12px; background: #333; margin: 10px 0; border: 2px solid #444; }
        .mode-listen { border-color: #3b82f6; color: #bfdbfe; }
        .mode-record { border-color: #ef4444; color: #fecaca; }
        .mode-replay { border-color: #10b981; color: #a7f3d0; }
        .mode-wait   { border-color: #9ca3af; color: #e5e7eb; }
        
        #currentSentence { font-size: 1.2rem; padding: 15px; border-left: 4px solid #f59e0b; background: #2a2a2a; min-height: 60px; margin: 10px 0; }
        .api-setup { border: 1px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 15px; background: #2a1b05; }
    </style>
</head>
<body>

    <h1>ğŸ” Shadowing Pro V4.0</h1>

    <div id="apiKeyPanel" class="card hidden">
        <h3 style="margin-top:0;">ğŸ”‘ è¨­å®š API Key</h3>
        <p style="color:#aaa; font-size:0.9rem;">ç‚ºäº†å®‰å…¨ï¼ŒKey ä¸æœƒå¯«åœ¨ç¨‹å¼ç¢¼ä¸­ï¼Œè€Œæ˜¯å„²å­˜åœ¨æ‚¨çš„æ‰‹æ©Ÿç€è¦½å™¨è£¡ã€‚</p>
        <input type="password" id="apiKeyInput" placeholder="è«‹è²¼ä¸Š sk-proj-...">
        <button id="saveKeyBtn" class="btn" style="background:#059669;">å„²å­˜ä¸¦é–‹å§‹</button>
    </div>

    <div id="setupPanel" class="card hidden">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <label style="font-weight:bold;">é¸æ“‡ MP3 éŸ³æª”ï¼š</label>
            <button onclick="clearKey()" style="background:none; border:none; color:#ef4444; font-size:0.9rem; text-decoration:underline;">é‡è¨­ Key</button>
        </div>
        <input type="file" id="audioInput" accept="audio/*">
        <p style="color:#888; font-size:0.9rem; margin-top:10px;">* åŸéŸ³æ’­æ”¾ 3 æ¬¡ (Loop)<br>* æ”¯æ´èƒŒæ™¯æ’­æ”¾ (WakeLock)</p>
        <button id="startBtn" class="btn" disabled>é–‹å§‹è™•ç† (AI)</button>
    </div>

    <div id="practicePanel" class="hidden">
        <div style="text-align:right; color:#aaa; font-size:0.9rem;" id="progressText">0 / 0</div>
        <div id="statusBox">æº–å‚™ä¸­...</div>
        <div id="currentSentence">...</div>
        <div style="margin-top:auto;">
            <button id="controlBtn" class="btn btn-control">â¸ï¸ æš«åœç·´ç¿’</button>
            <button id="resetBtn" class="btn" style="background:#555; margin-top:10px;">âŒ çµæŸ</button>
        </div>
    </div>

    <audio id="audioPlayer"></audio>
    <audio id="recordingPlayer"></audio>

<script>
// --- å…¨åŸŸè®Šæ•¸ ---
let USER_API_KEY = "";
const REPEAT_COUNT = 3; 

const state = { sentences: [], currentIndex: 0, audioBlob: null, isPaused: false, wakeLock: null };
const dom = {
    apiKeyPanel: document.getElementById('apiKeyPanel'),
    apiKeyInput: document.getElementById('apiKeyInput'),
    saveKeyBtn: document.getElementById('saveKeyBtn'),
    setupPanel: document.getElementById('setupPanel'),
    practicePanel: document.getElementById('practicePanel'),
    audioInput: document.getElementById('audioInput'),
    startBtn: document.getElementById('startBtn'),
    statusBox: document.getElementById('statusBox'),
    currentSentence: document.getElementById('currentSentence'),
    progressText: document.getElementById('progressText'),
    controlBtn: document.getElementById('controlBtn'),
    resetBtn: document.getElementById('resetBtn'),
    audioPlayer: document.getElementById('audioPlayer'),
    recordingPlayer: document.getElementById('recordingPlayer')
};

// --- 0. åˆå§‹åŒ–ï¼šæª¢æŸ¥æ˜¯å¦æœ‰å„²å­˜çš„ Key ---
// é€™è£¡æœƒè‡ªå‹•å¾ç€è¦½å™¨ LocalStorage æŠ“å–ï¼Œå¦‚æœæ²’æœ‰å°±é¡¯ç¤ºè¼¸å…¥æ¡†
(function init() {
    const savedKey = localStorage.getItem("my_openai_key");
    if (savedKey && savedKey.startsWith("sk-")) {
        USER_API_KEY = savedKey;
        showSetup();
    } else {
        dom.apiKeyPanel.classList.remove('hidden');
    }
})();

dom.saveKeyBtn.addEventListener('click', () => {
    const inputKey = dom.apiKeyInput.value.trim();
    if (inputKey.includes("sk-") && inputKey.length > 20) {
        localStorage.setItem("my_openai_key", inputKey); // å­˜å…¥æ‰‹æ©Ÿ
        USER_API_KEY = inputKey;
        dom.apiKeyPanel.classList.add('hidden');
        showSetup();
    } else {
        alert("Key æ ¼å¼çœ‹èµ·ä¾†æ€ªæ€ªçš„ï¼Œè«‹æª¢æŸ¥ä¸€ä¸‹å–”ï¼(å¿…é ˆåŒ…å« sk-)");
    }
});

window.clearKey = () => {
    if(confirm("ç¢ºå®šè¦æ¸…é™¤å„²å­˜çš„ Key å—ï¼Ÿ")) {
        localStorage.removeItem("my_openai_key");
        location.reload();
    }
};

function showSetup() {
    dom.setupPanel.classList.remove('hidden');
}

// --- 1. é–‹å§‹æµç¨‹ ---
dom.audioInput.addEventListener('change', (e) => {
    if (e.target.files[0]) {
        state.audioBlob = e.target.files[0];
        dom.audioPlayer.src = URL.createObjectURL(state.audioBlob);
        dom.startBtn.disabled = false;
        dom.startBtn.textContent = "ğŸš€ é–‹å§‹ AI åˆ†æ";
    }
});

dom.startBtn.addEventListener('click', async () => {
    if (state.audioBlob.size > 25 * 1024 * 1024) {
        alert("âš ï¸ æª”æ¡ˆå¤ªå¤§äº† (è¶…é 25MB)ï¼\nOpenAI æœƒæ‹’æ”¶ã€‚\nè«‹å…ˆç”¨ç·šä¸Šå·¥å…·å£“ç¸® MP3 æª”æ¡ˆã€‚");
        return;
    }

    dom.startBtn.disabled = true;
    dom.startBtn.textContent = "AI è™•ç†ä¸­...";
    
    try {
        if ('wakeLock' in navigator) try { state.wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
        await generateTranscript();
        
        if (state.sentences.length === 0) throw new Error("AI å›å‚³äº†ç©ºçš„å…§å®¹ï¼Œè«‹ç¢ºèªæª”æ¡ˆéŸ³è¨Šæ­£å¸¸ã€‚");

        dom.setupPanel.classList.add('hidden');
        dom.practicePanel.classList.remove('hidden');
        state.isPaused = false;
        runLoop();
    } catch (err) {
        alert("âŒ éŒ¯èª¤ï¼š" + err.message);
        dom.startBtn.disabled = false;
        dom.startBtn.textContent = "é‡è©¦";
    }
});

// --- 2. å¾ªç’°é‚è¼¯ ---
async function runLoop() {
    while (state.currentIndex < state.sentences.length) {
        if (state.isPaused) return;
        const s = state.sentences[state.currentIndex];
        updateUI(s);

        // è½ 3 æ¬¡
        for (let i = 1; i <= REPEAT_COUNT; i++) {
            if (state.isPaused) return;
            setStatus('listen', `ğŸ‘‚ åŸéŸ³ (${i}/${REPEAT_COUNT})`);
            await playAudioSegment(s.start, s.end);
            await wait(800);
        }

        // éŒ„éŸ³
        if (state.isPaused) return;
        setStatus('record', 'ğŸ¤ è«‹è·Ÿè®€');
        const duration = (s.end - s.start) * 1000 + 1000;
        const userBlob = await recordAudio(duration);

        // å›æ”¾
        if (state.isPaused) return;
        setStatus('replay', 'ğŸ§ è½ä½ çš„ç™¼éŸ³');
        dom.recordingPlayer.src = URL.createObjectURL(userBlob);
        await playUserRecording();

        // ç­‰å¾…
        if (state.isPaused) return;
        setStatus('wait', 'â³ ä¸‹ä¸€å¥...');
        await wait(1500);

        if (!state.isPaused) state.currentIndex++;
    }
    if (state.currentIndex >= state.sentences.length) {
        setStatus('wait', 'ğŸ‰ ç·´ç¿’çµæŸï¼');
        alert("æ­å–œå®Œæˆï¼");
    }
}

// --- æ§åˆ¶æŒ‰éˆ• ---
dom.controlBtn.addEventListener('click', () => {
    if (state.isPaused) {
        state.isPaused = false;
        dom.controlBtn.textContent = "â¸ï¸ æš«åœç·´ç¿’";
        dom.controlBtn.classList.remove('paused');
        if (dom.statusBox.textContent.includes('æš«åœ')) runLoop(); 
    } else {
        state.isPaused = true;
        dom.controlBtn.textContent = "â–¶ï¸ ç¹¼çºŒç·´ç¿’";
        dom.controlBtn.classList.add('paused');
        dom.audioPlayer.pause();
        dom.recordingPlayer.pause();
        setStatus('wait', 'ğŸ›‘ å·²æš«åœ');
    }
});

dom.resetBtn.addEventListener('click', () => { if(confirm('ç¢ºå®šè¦çµæŸå—ï¼Ÿ')) location.reload(); });

// --- API ---
async function generateTranscript() {
    const formData = new FormData();
    formData.append('file', state.audioBlob);
    formData.append('model', 'whisper-1');
    formData.append('response_format', 'verbose_json');

    const res = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${USER_API_KEY}` }, // ä½¿ç”¨å„²å­˜çš„ Key
        body: formData
    });

    if (!res.ok) {
        if(res.status === 401) throw new Error("Key éŒ¯èª¤ï¼è«‹æŒ‰å·¦ä¸Šè§’ã€Œé‡è¨­ Keyã€é‡æ–°è¼¸å…¥ã€‚");
        throw new Error(`API é€£ç·šå¤±æ•— (${res.status})`);
    }

    const data = await res.json();
    if (data.segments) {
        state.sentences = data.segments.map(seg => ({ text: seg.text.trim(), start: seg.start, end: seg.end }));
    } else {
        state.sentences = [{ text: data.text, start: 0, end: dom.audioPlayer.duration }];
    }
}

// --- å·¥å…· ---
function playAudioSegment(start, end) {
    return new Promise(resolve => {
        if (state.isPaused) { resolve(); return; }
        dom.audioPlayer.currentTime = start;
        dom.audioPlayer.play();
        const check = setInterval(() => {
            if (state.isPaused) { dom.audioPlayer.pause(); clearInterval(check); resolve(); return; }
            if (dom.audioPlayer.currentTime >= end || dom.audioPlayer.ended) { dom.audioPlayer.pause(); clearInterval(check); resolve(); }
        }, 50);
    });
}
function playUserRecording() {
    return new Promise(resolve => {
        if (state.isPaused) { resolve(); return; }
        dom.recordingPlayer.play();
        dom.recordingPlayer.onended = resolve;
    });
}
async function recordAudio(ms) {
    if (state.isPaused) return new Blob();
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mediaRecorder = new MediaRecorder(stream);
        const chunks = [];
        mediaRecorder.ondataavailable = e => chunks.push(e.data);
        mediaRecorder.start();
        return new Promise(resolve => {
            let stopped = false;
            const timer = setTimeout(() => { if (!stopped && mediaRecorder.state === 'recording') mediaRecorder.stop(); }, ms);
            const checkPause = setInterval(() => { if (state.isPaused && !stopped) { clearTimeout(timer); if (mediaRecorder.state === 'recording') mediaRecorder.stop(); stopped = true; } }, 100);
            mediaRecorder.onstop = () => { clearInterval(checkPause); stream.getTracks().forEach(t => t.stop()); resolve(new Blob(chunks, {type:'audio/ogg'})); };
        });
    } catch (e) { console.error(e); return new Blob(); }
}
function setStatus(mode, text) { dom.statusBox.className = `mode-${mode}`; dom.statusBox.textContent = text; }
function updateUI(s) {
    dom.currentSentence.textContent = s.text;
    dom.progressText.textContent = `${state.currentIndex + 1} / ${state.sentences.length}`;
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
</script>
</body>
</html>
